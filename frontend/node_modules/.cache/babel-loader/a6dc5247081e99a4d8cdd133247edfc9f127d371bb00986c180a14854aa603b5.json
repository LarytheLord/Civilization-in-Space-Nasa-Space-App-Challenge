{"ast":null,"code":"import _objectSpread from\"C:/Users/A R Khan/OneDrive/Documents/Nasa/robot/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import{useEffect,useState,useRef,useCallback}from'react';export const useWebSocket=url=>{const[data,setData]=useState({});const[connected,setConnected]=useState(false);const[reconnectAttempts,setReconnectAttempts]=useState(0);const wsRef=useRef(null);const reconnectTimeoutRef=useRef(null);// Maximum number of reconnection attempts\nconst maxReconnectAttempts=10;// Reconnection delay in milliseconds\nconst reconnectDelay=3000;const connect=useCallback(()=>{try{if(wsRef.current){wsRef.current.close();}wsRef.current=new WebSocket(url);wsRef.current.onopen=()=>{console.log('WebSocket connected');setConnected(true);setReconnectAttempts(0);// Reset attempts on successful connection\n};wsRef.current.onmessage=event=>{try{const message=JSON.parse(event.data);setData(prev=>_objectSpread(_objectSpread({},prev),{},{[message.type]:message.data}));}catch(error){console.error('Error parsing WebSocket message:',error);}};wsRef.current.onclose=()=>{console.log('WebSocket disconnected');setConnected(false);// Attempt to reconnect if we haven't exceeded max attempts\nif(reconnectAttempts<maxReconnectAttempts){console.log(\"Attempting to reconnect... (\".concat(reconnectAttempts+1,\"/\").concat(maxReconnectAttempts,\")\"));setReconnectAttempts(prev=>prev+1);if(reconnectTimeoutRef.current){clearTimeout(reconnectTimeoutRef.current);}reconnectTimeoutRef.current=setTimeout(()=>{connect();},reconnectDelay);}else{console.error('Max reconnection attempts reached. Please refresh the page.');}};wsRef.current.onerror=error=>{console.error('WebSocket error:',error);setConnected(false);};}catch(error){console.error('Failed to create WebSocket connection:',error);setConnected(false);// Attempt to reconnect if we haven't exceeded max attempts\nif(reconnectAttempts<maxReconnectAttempts){console.log(\"Attempting to reconnect... (\".concat(reconnectAttempts+1,\"/\").concat(maxReconnectAttempts,\")\"));setReconnectAttempts(prev=>prev+1);if(reconnectTimeoutRef.current){clearTimeout(reconnectTimeoutRef.current);}reconnectTimeoutRef.current=setTimeout(()=>{connect();},reconnectDelay);}}},[url,maxReconnectAttempts,reconnectDelay]);useEffect(()=>{connect();return()=>{// Clear any pending reconnection timeout\nif(reconnectTimeoutRef.current){clearTimeout(reconnectTimeoutRef.current);}// Close the WebSocket connection\nif(wsRef.current){wsRef.current.close();}};},[connect]);// Function to manually trigger a reconnect\nconst manualReconnect=useCallback(()=>{if(reconnectTimeoutRef.current){clearTimeout(reconnectTimeoutRef.current);}setReconnectAttempts(0);connect();},[connect]);return{data,connected,reconnect:manualReconnect};};","map":{"version":3,"names":["useEffect","useState","useRef","useCallback","useWebSocket","url","data","setData","connected","setConnected","reconnectAttempts","setReconnectAttempts","wsRef","reconnectTimeoutRef","maxReconnectAttempts","reconnectDelay","connect","current","close","WebSocket","onopen","console","log","onmessage","event","message","JSON","parse","prev","_objectSpread","type","error","onclose","concat","clearTimeout","setTimeout","onerror","manualReconnect","reconnect"],"sources":["C:/Users/A R Khan/OneDrive/Documents/Nasa/robot/frontend/src/hooks/useWebSocket.ts"],"sourcesContent":["import { useEffect, useState, useRef, useCallback } from 'react';\n\nexport const useWebSocket = (url: string) => {\n  const [data, setData] = useState<any>({});\n  const [connected, setConnected] = useState(false);\n  const [reconnectAttempts, setReconnectAttempts] = useState(0);\n  const wsRef = useRef<WebSocket | null>(null);\n  const reconnectTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n\n  // Maximum number of reconnection attempts\n  const maxReconnectAttempts = 10;\n  // Reconnection delay in milliseconds\n  const reconnectDelay = 3000;\n\n  const connect = useCallback(() => {\n    try {\n      if (wsRef.current) {\n        wsRef.current.close();\n      }\n      \n      wsRef.current = new WebSocket(url);\n\n      wsRef.current.onopen = () => {\n        console.log('WebSocket connected');\n        setConnected(true);\n        setReconnectAttempts(0); // Reset attempts on successful connection\n      };\n\n      wsRef.current.onmessage = (event) => {\n        try {\n          const message = JSON.parse(event.data);\n          setData((prev: any) => ({\n            ...prev,\n            [message.type]: message.data\n          }));\n        } catch (error) {\n          console.error('Error parsing WebSocket message:', error);\n        }\n      };\n\n      wsRef.current.onclose = () => {\n        console.log('WebSocket disconnected');\n        setConnected(false);\n        \n        // Attempt to reconnect if we haven't exceeded max attempts\n        if (reconnectAttempts < maxReconnectAttempts) {\n          console.log(`Attempting to reconnect... (${reconnectAttempts + 1}/${maxReconnectAttempts})`);\n          setReconnectAttempts(prev => prev + 1);\n          \n          if (reconnectTimeoutRef.current) {\n            clearTimeout(reconnectTimeoutRef.current);\n          }\n          \n          reconnectTimeoutRef.current = setTimeout(() => {\n            connect();\n          }, reconnectDelay);\n        } else {\n          console.error('Max reconnection attempts reached. Please refresh the page.');\n        }\n      };\n\n      wsRef.current.onerror = (error) => {\n        console.error('WebSocket error:', error);\n        setConnected(false);\n      };\n    } catch (error) {\n      console.error('Failed to create WebSocket connection:', error);\n      setConnected(false);\n      \n      // Attempt to reconnect if we haven't exceeded max attempts\n      if (reconnectAttempts < maxReconnectAttempts) {\n        console.log(`Attempting to reconnect... (${reconnectAttempts + 1}/${maxReconnectAttempts})`);\n        setReconnectAttempts(prev => prev + 1);\n        \n        if (reconnectTimeoutRef.current) {\n          clearTimeout(reconnectTimeoutRef.current);\n        }\n        \n        reconnectTimeoutRef.current = setTimeout(() => {\n          connect();\n        }, reconnectDelay);\n      }\n    }\n  }, [url, maxReconnectAttempts, reconnectDelay]);\n\n  useEffect(() => {\n    connect();\n\n    return () => {\n      // Clear any pending reconnection timeout\n      if (reconnectTimeoutRef.current) {\n        clearTimeout(reconnectTimeoutRef.current);\n      }\n      \n      // Close the WebSocket connection\n      if (wsRef.current) {\n        wsRef.current.close();\n      }\n    };\n  }, [connect]);\n\n  // Function to manually trigger a reconnect\n  const manualReconnect = useCallback(() => {\n    if (reconnectTimeoutRef.current) {\n      clearTimeout(reconnectTimeoutRef.current);\n    }\n    setReconnectAttempts(0);\n    connect();\n  }, [connect]);\n\n  return { data, connected, reconnect: manualReconnect };\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}